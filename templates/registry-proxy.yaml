{{- if and .Values.registry.enabled .Values.registry.proxy.enabled }}

# MARK: ConfigMap 'cora-registry-proxy'
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "common.fullname" . }}-registry-proxy
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "common.labels" . | nindent 4 }}
    app.kubernetes.io/component: registry-proxy
data:
  nginx.conf: |
    user nginx;
    worker_processes auto;

    error_log /dev/stderr warn;

    events { worker_connections 1024; }

    http {
      include       /etc/nginx/mime.types;
      default_type  application/octet-stream;

      sendfile on;
      keepalive_timeout 65;

      # Request-id: reuse incoming if present, otherwise generate something stable-ish
      map $http_x_request_id $req_id {
        default $http_x_request_id;
        ""      "$pid-$msec-$remote_addr";
      }

      # Avoid health/metrics spam
      map $request_uri $loggable {
        default 1;
        ~^/healthz$ 0;
        ~^/readyz$  0;
        ~^/metrics$ 0;
      }

      # Extract scope=... if present
      map $upstream_http_www_authenticate $registry_request_scope {
        "~*(scope=\"[^\"]+\")" ",$1";
        "~*(scope=[^, ]+)"     ",$1";
        default                "";
      }

      # NOTE: That one used by CORA Devs
      # map $upstream_http_www_authenticate $registry_request_scope {
      #   ~(.*)(,)(.*)(,)(.*)  $5;
      #   default "";
      # }

      log_format json escape=json
      '{'
        '"time":"$time_iso8601",'
        '"req_id":"$req_id",'
        '"remote_addr":"$remote_addr",'
        '"xff":"$http_x_forwarded_for",'
        '"host":"$host",'
        '"method":"$request_method",'
        '"uri":"$request_uri",'
        '"status":$status,'
        '"bytes_sent":$bytes_sent,'
        '"request_length":$request_length,'
        '"request_time":$request_time,'
        '"upstream_addr":"$upstream_addr",'
        '"upstream_status":"$upstream_status",'
        '"upstream_response_time":"$upstream_response_time",'
        '"user_agent":"$http_user_agent"'
      '}';

      access_log /dev/stdout json if=$loggable;

      # https://wiki.mozilla.org/Security/Server_Side_TLS#Modern_compatibility
      ssl_protocols              TLSv1.2 TLSv1.3;
      ssl_ecdh_curve             X25519:prime256v1:secp384r1;
      ssl_ciphers                ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-CHACHA20-POLY1305;
      ssl_prefer_server_ciphers  off;

      ssl_session_timeout  1d;
      ssl_session_cache   shared:MozSSL:10m;

      server {
        set $docker_external_host  "dev-op-registry.merck.com";
        set $realm_external_host   "dev-op.merck.com";
        set $realm_external_port   "443";
        set $realm_internal_host   "dev-op.merck.com";
        set $realm_internal_port   "443";
        set $docker_internal_host  "dev-op-registry.merck.com";
        set $docker_internal_port  "443";

        listen 443 ssl;
        server_name _;

        ssl_certificate      /etc/nginx/tls/tls.crt;
        ssl_certificate_key  /etc/nginx/tls/tls.key;

        client_max_body_size 0;

        proxy_http_version       1.1;
        proxy_buffering          off;
        proxy_request_buffering  off;

        #chunked_transfer_encoding on;

        add_header X-Request-Id $req_id always;

        location = / {
          add_header Content-Type text/plain;
          return 200 "OK\n";
        }

        location = /healthz {
          access_log off;
          add_header Content-Type text/plain;
          return 200 "OK\n";
        }

        location = /readyz {
          access_log off;
          proxy_pass http://cora-registry-backend:5001/metrics;
          proxy_connect_timeout  2s;
          proxy_send_timeout     2s;
          proxy_read_timeout     5s;
        }

        location /v2/ {
          proxy_pass http://cora-registry-backend:5000;

          proxy_set_header  Host               $http_host;
          proxy_set_header  X-Real-IP          $remote_addr;
          proxy_set_header  X-Forwarded-For    $proxy_add_x_forwarded_for;
          proxy_set_header  X-Forwarded-Proto  $scheme;

          proxy_set_header  Connection         "";
          proxy_set_header  Authorization      $http_authorization;
          proxy_set_header  X-Request-Id       $req_id;

          proxy_connect_timeout  10s;
          proxy_send_timeout     600s;
          proxy_read_timeout     900s;

          set $realm_endpoint "${realm_internal_host}:${realm_internal_port}";
          if ($host = $docker_external_host) {
            set $realm_endpoint "${realm_external_host}:${realm_external_port}";
          }

          proxy_hide_header Www-Authenticate;
          add_header Www-Authenticate 'Bearer realm="https://${realm_endpoint}/pipeline/restapi/dockerRegistry/oauth",service="${docker_internal_host}:${docker_internal_port}",${registry_request_scope}' always;
        }

        location = /favicon.ico {
          log_not_found off;
        }

        location = /robots.txt {
          log_not_found off;
        }
      }

      server {
        listen 80 default_server;
        #listen [::]:80 default_server;
        return 308 https://$host$request_uri;
      }

      include /etc/nginx/conf.d/*.conf;
    }

# MARK: Service 'cora-registry'
---
apiVersion: v1
kind: Service
metadata:
  name: {{ include "common.fullname" . }}-registry
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "common.labels" . | nindent 4 }}
    app.kubernetes.io/component: registry-proxy
spec:
  type: ClusterIP
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: http
    - name: https
      protocol: TCP
      port: 443
      targetPort: https
  selector:
    {{- include "common.selectorLabels" . | nindent 4 }}
    app.kubernetes.io/component: registry-proxy

# MARK: Deployment 'cora-registry-proxy'
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "common.fullname" . }}-registry-proxy
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "common.labels" . | nindent 4 }}
    app.kubernetes.io/component: registry-proxy
    # cloud-pipeline/cp-docker-registry: "true"
spec:
  replicas: 1
  selector:
    matchLabels:
      {{- include "common.selectorLabels" . | nindent 6 }}
      app.kubernetes.io/component: registry-proxy
      # cloud-pipeline/cp-docker-registry: "true"
  template:
    metadata:
      annotations:
        checksum/config: {{ .Values.registry.config | toYaml | sha256sum }}
      labels:
        {{- include "common.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: registry-proxy
        # cloud-pipeline/cp-docker-registry: "true"
    spec:
      containers:
        - name: nginx
          image: "{{ .Values.registry.proxy.image.repository }}:{{ .Values.registry.proxy.image.tag }}"
          ports:
            - name: http
              protocol: TCP
              containerPort: 80
            - name: https
              protocol: TCP
              containerPort: 443
          resources:
            requests:
              cpu: 100m
              memory: 100Mi
            limits:
              cpu: 100m
              memory: 100Mi
          volumeMounts:
            - name: tls
              mountPath: /etc/nginx/tls
              readOnly: true
            - name: conf
              mountPath: /etc/nginx/nginx.conf
              subPath: nginx.conf
              readOnly: true
      securityContext: {}
      tolerations:
        - effect: NoSchedule
          key: node-role.kubernetes.io/master
      volumes:
        - name: tls
          secret:
            secretName: {{ include "common.fullname" . }}-tls
        - name: conf
          configMap:
            name: {{ include "common.fullname" . }}-registry-proxy

{{- end }}
